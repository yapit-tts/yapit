---
status: done
started: 2026-02-10
---

# Task: AST-Based Content Rendering Refactor

## Intent

Replace `dangerouslySetInnerHTML` content rendering with React component tree built from the existing AST. Eliminates the class of bugs where React re-renders destroy post-render DOM modifications (KaTeX math rendering, event handlers). Removes DOMPurify dependency entirely.

**Non-negotiable constraint:** Old documents with missing AST fields must degrade to empty content, NEVER crash the page. The Jan 25 parser rewrite caused page crashes that required deleting old documents — that must not repeat.

## Background — Why This Matters

The current architecture has a fundamental mismatch:

```
Backend AST → render to HTML string → Frontend injects as opaque blob via dangerouslySetInnerHTML
→ Post-render useEffect scans DOM for .math-inline spans → KaTeX renders them
→ React re-renders (section expand, highlight, etc.) → Replaces entire inner DOM
→ KaTeX output destroyed → useEffect may not re-fire → Bug
```

The AST approach:

```
Backend AST → Frontend renders as React components → React owns lifecycle → KaTeX is a component → Done
```

### Bugs This Fixes

1. **LaTeX "reload required"** — KaTeX useEffect depends on `[structuredContent]` but DOM gets replaced by re-renders from section state changes without re-triggering the effect.
2. **LaTeX "unrendering during playback"** — Section auto-expand during playback triggers re-render → dangerouslySetInnerHTML replaces KaTeX output → effect doesn't re-fire.
3. **Tables with LaTeX needing reload** — Same root cause, tables also use dangerouslySetInnerHTML.

### What Gets Removed

- Post-render KaTeX scanning useEffect (structuredDocument.tsx:873-890) — the bug source
- All 11 `dangerouslySetInnerHTML` call sites in block views
- `DOMPurify` import and `sanitize()` wrapper — zero innerHTML means zero XSS surface
- `processInlineMath()` regex hack (line 531) — was converting `$...$` to spans for image captions
- Event delegation in `handleContentClick` for content links — links become React event handlers

## Assumptions

- All documents created after the Jan 25 parser rewrite have `block.ast` populated (confirmed via git history: `c9b68a6`).
- Documents from before that rewrite were already deleted due to page crashes.
- `AudioChunk.ast` and table cell AST are NEW fields — no existing documents have them. Old documents will render empty for affected content until re-extracted.
- User will re-extract showcase/important documents after the refactor.
- The `html` field continues to be generated by the backend (no urgency to remove `render_ast_to_html`), but the frontend won't read it.

## Plan

### Backend Changes

**1. Add `ast` to `AudioChunk` model** (`models.py`):
```python
class AudioChunk(BaseModel):
    text: str
    audio_block_idx: int
    ast: list[InlineContent] = Field(default_factory=list)
```

**2. Populate chunk ASTs in `split_with_spans`** (`transformer.py`):
- Multi-chunk path (~line 597): `AudioChunk(..., ast=sliced_ast)` — already computed, just store it
- Single-chunk path (~line 574): `AudioChunk(..., ast=ast)` — pass the full AST through

**3. Audit ALL other `AudioChunk` creation sites** — every place that creates an AudioChunk must include `ast`. Search for `AudioChunk(` across the transformer.

**4. Add `ast` to table cells** — Change `TableBlock` model:
```python
class TableCell(BaseModel):
    html: str
    ast: list[InlineContent] = Field(default_factory=list)

class TableBlock(BaseModel):
    headers: list[TableCell]
    rows: list[list[TableCell]]
```
Update `_transform_table` to call `transform_inline_to_ast()` per cell (it already has the AST nodes via `InlineProcessor` — just needs the additional call).

**5. Add `caption_ast` to `ImageBlock`** — or rely on per-chunk ASTs from AudioChunk. The latter is cleaner (unifies all block types). Currently `caption_ast` is computed but discarded (transformer.py:1059-1065).

**6. Backend security fix** — In `InlineProcessor._node_to_html()` (line 172-174), escape or drop raw `html_inline` nodes instead of passing them through. Defense in depth — the `html` field shouldn't carry XSS payloads regardless of frontend usage. Not urgent but should be part of this refactor since we're touching the transformer anyway.

**7. Fix multi-line yap tag handling** (bug) — Multi-line `<yap-show>` blocks (tag on own line with content spanning lines) get classified as `html_block` by markdown-it (per CommonMark spec). The transformer has no `html_block` handler → content silently dropped.

Fix: add `html_block` handler (~25-30 lines) that:
1. Detects yap tags in the raw `html_block` content string
2. Extracts the inner markdown
3. Re-parses it through the same markdown-it parser (full markdown treatment — formatting, math, links, lists, etc.)
4. Transforms the resulting AST through the same transformer (normal blocks with full AST)
5. Recursively strips `audio_chunks` from all resulting blocks (making them display-only)

This means multi-line `<yap-show>` content gets the same treatment as regular markdown — just without audio. Blocks with empty `audio_chunks` already work this way (code blocks, tables, etc.).

For `<yap-speak>` in `html_block`: drop entirely (TTS-only content, not displayed).

Side effect: transformer's `audio_idx_counter` increments during inner processing then indices go unused (gaps). The playback engine builds its index from actual chunks, so gaps are harmless.

TDD: write test with multi-line `<yap-show>` containing formatted markdown (bold, math, lists), assert all content appears in output blocks with empty audio_chunks and correct AST.

### Frontend Changes

**0. Fix `visibleBlocks` filter hiding display-only blocks before first heading** (`structuredDocument.tsx:1092-1098`):
The outliner's `visibleBlocks` filter drops blocks with no `audio_chunks` that appear before the first heading — `lastSeenSectionId` is `null`, so the block is excluded. This hides yap-show content (copyright notices, attribution) that typically precedes headings. Also affects code blocks/tables/HRs before headings, but those rarely appear there so the bug was latent.
Fix: blocks with `undefined` audioIdx should be included regardless of section state when `lastSeenSectionId` is null.
```tsx
// Current (broken): silently drops blocks before first heading
if (audioIdx === undefined) {
    if (lastSeenSectionId && expandedSections.has(lastSeenSectionId) && !skipped.has(lastSeenSectionId)) {
        visible.push(block);
    }
    continue;
}
// Fix: include display-only blocks even before first heading
if (audioIdx === undefined) {
    if (!lastSeenSectionId || (expandedSections.has(lastSeenSectionId) && !skipped.has(lastSeenSectionId))) {
        visible.push(block);
    }
    continue;
}
```

**1. New component: `frontend/src/components/inlineContent.tsx`** (~100-120 lines):
- `InlineContentRenderer` — recursive mapper: `InlineContent[]` → React elements
- `InlineMath` — `useRef` + `useEffect([content])` for KaTeX rendering
- `FootnoteRef` — superscript link component
- Link component with React `onClick` handler (replaces event delegation)

All renderers must handle missing/null/undefined data gracefully — render empty, never throw.

**2. Update TypeScript types** in `structuredDocument.tsx`:
- `AudioChunk` gets optional `ast?: InlineContent[]`
- `TableBlock` headers/rows become `TableCell[]` / `TableCell[][]`
- Types must be optional/defaulted so old JSON doesn't cause type errors

**3. Update block views** — swap `dangerouslySetInnerHTML` → `<InlineContentRenderer>`:
- For blocks with single audio chunk: render `block.ast` directly
- For blocks with multiple audio chunks: render per-chunk `chunk.ast` wrapped in `<span data-audio-idx={chunk.audio_block_idx}>`
- For blocks where `ast` is empty/missing: render nothing (graceful degradation)

**4. Add React error boundary** around the content rendering area. If any renderer throws despite defensive coding, the page stays navigable — just that block fails with a fallback UI, not a white screen.

**5. Remove old code:**
- KaTeX scanning useEffect
- `sanitize()` function and DOMPurify import
- `processInlineMath()` regex function
- Content link event delegation from `handleContentClick` (keep `data-audio-block-idx` click handling for block-level clicks)

### Testing Strategy

**TDD (write tests BEFORE implementation):**

1. **Backend roundtrip invariant** (`test_markdown.py`): For each block type with audio, assert `render_ast_to_html(chunk.ast)` produces the same HTML that `split_with_spans` generated. This is the key correctness invariant — if the AST roundtrips to equivalent HTML, the frontend renderer (which does the same mapping to React elements) will produce equivalent output. Cover: paragraph (single + multi-chunk), heading, list item, image caption, blockquote callout title, footnote item.

2. **Backend table cell AST** (`test_markdown.py`): Assert `TableCell.ast` is populated for various content — plain text, math, links, formatting, mixed.

3. **Frontend InlineContentRenderer** (`inlineContent.test.tsx`): One test per node type (text, code_span, strong, emphasis, link, inline_image, math_inline, speak, show, footnote_ref). Test nesting (strong inside link, math inside show, deeply nested). Test audio chunk span wrapping (multiple chunks → spans with `data-audio-idx`).

4. **Frontend robustness** (`inlineContent.test.tsx`): Empty ast → empty render. `undefined` ast → empty render (simulating old documents). Block with missing `chunk.ast` → empty or block-level ast fallback. Unknown node type → skip without throwing. These tests define the "don't crash" contract.

5. **Error boundary** (`structuredDocument.test.tsx` or similar): Renderer throwing → fallback UI shown, page navigable.

**Test-after (write alongside or immediately after implementation):**

6. **Block view rendering**: After swapping each block view, verify it renders with correct content for representative AST inputs.

7. **KaTeX re-render survival** (regression test): Render `<InlineMath>`, re-render parent, assert KaTeX output persists. Low risk of failure given the architecture, but documents the guarantee.

8. **Backend `html_inline` escaping**: Assert raw HTML in markdown → escaped/dropped in both `html` and `ast` output.

**Manual E2E (agent via Chrome DevTools MCP + user verification):**

9. Visual parity — does the rendered output look identical to the old HTML-based rendering? CSS, spacing, font rendering. Agent: take screenshots before/after refactor on a test document with diverse content (math, tables, lists, images, footnotes, callouts).

10. Section expand/collapse with LaTeX — the exact bug scenario. Agent: expand/collapse sections containing math, take screenshots, verify KaTeX persists.

11. Playback highlighting — `data-audio-idx` span queries still work. Agent: start playback, verify blocks highlight correctly via DevTools snapshot.

12. Old document graceful degradation — load a pre-refactor document (without chunk ASTs), verify empty content renders without page crash. Agent: navigate to an old document, take screenshot, check console for errors.

13. Re-extracted document — re-extract a test document, verify full content renders correctly with new AST path. Compare to pre-refactor rendering.

User does final E2E pass on all the above before merge to main.

**What's NOT tested and why:**

- **Performance on large documents** — React component trees vs innerHTML. Unlikely to regress (React reconciliation is fast, and we're not rendering thousands of components at once due to section collapsing). Monitor after deploy if concerned.
- **Full outliner state machine interaction** — Complex setup (need outliner + filtered playback + section state). The architecture makes the KaTeX bug structurally impossible; manual E2E is sufficient.

### Execution Order (TDD)

**Session 1 — Backend (feature branch `ast-renderer`):**

1. **Write backend tests** — roundtrip invariant for each block type, table cell AST tests, multi-line yap-show test. Run → all fail.
2. Backend: Add `ast` to `AudioChunk` + populate in all creation sites. Run tests → pass.
3. Backend: Add `TableCell` model + update `_transform_table`. Run tests → pass.
4. Backend: Add `html_block` handler for multi-line yap tags + test.
5. Backend: Fix `html_inline` pass-through + test.
6. `make dev-cpu`, re-extract a test document, inspect JSON output — verify chunk ASTs are correct.

**Session 2 — Frontend (same branch):**

7. **Write frontend renderer tests** — each node type, nesting, robustness. Run → all fail (component doesn't exist).
8. Frontend: Implement `InlineContentRenderer` node by node. Tests go green incrementally.
9. **Write error boundary test.** Implement error boundary.
10. Frontend: Swap block views one at a time (heading → paragraph → list → image caption → footnotes → blockquote → table). Write block-level tests alongside.
11. Frontend: Remove old KaTeX useEffect, DOMPurify, processInlineMath, sanitize.
12. `make dev-cpu`. Agent E2E via Chrome DevTools MCP (screenshots, console checks, playback test, old document test, re-extracted document test).
13. User E2E verification. Squash-merge to main when satisfied.

### No Backwards Compatibility

Old documents render with empty content where AST is missing. No fallback to `dangerouslySetInnerHTML`. No DOMPurify. User re-extracts documents they want to use.

The ONLY defensive measure is: missing data → empty render + error boundary as safety net. Not: missing data → fall back to old rendering path.

## Done When

- [x] All `dangerouslySetInnerHTML` removed from block views
- [x] DOMPurify dependency removed
- [x] KaTeX renders correctly on initial load (no reload needed)
- [x] KaTeX survives section expand/collapse and playback highlighting
- [x] Old documents without AST show empty content, don't crash
- [x] Error boundary catches renderer failures without killing the page
- [x] Backend tests verify chunk ASTs are populated
- [x] Frontend tests verify renderer handles all node types + missing data
- [x] `html_inline` pass-through fixed in backend
- [x] Hardbreak support (currently renders as space, should render as `<br>`)
- [x] Update transformer/parser knowledge docs

## Work Completed (Sessions 1–5)

**Commits:** `738643c` (backend AST), `07a1ae2` (CI), `dc309db` (nested lists + frontend + yap-show fix), pending (hardbreaks + knowledge docs)

**Backend:** AudioChunk.ast populated everywhere, TableCell AST, ListContent model, `_build_nested_list_ast`, independent segment splitting for nested lists, atomic ListContent slicing, `html_inline` XSS fix, multi-line `<yap-show>` handler, yap-show audio index gap fix, HardbreakContent model + AST/slicing/rendering.

**Frontend:** InlineContentRenderer (all inline types including hardbreak), NestedList component, ListBlockView with separated visible/lost chunk rendering, filterVisibleBlocks extracted + bug fix, AudioContent helper, BlockErrorBoundary. All dangerouslySetInnerHTML swapped, DOMPurify removed.

**Tests:** 252 backend + 72 frontend = 324 total, all passing.

### Known Limitations

- **Nested lists highlight as a unit** — the text splitter works on flat text and doesn't know nested list item boundaries. Per-chunk highlighting within nested lists would require a structure-aware splitter. Not worth the complexity.
- **Alternating paragraph→list→paragraph→list within one item** — frontend renders all text first, all lists after. Extremely rare in practice.

## Considered & Rejected

### useLayoutEffect band-aid
Replace `useEffect` with `useLayoutEffect` (no deps) + `.katex-rendered` class guard. Fixes the immediate KaTeX bug but keeps the fundamental architecture flaw. Every future feature that interacts with content DOM would hit the same class of problems. Rejected in favor of solving the root cause.

### MutationObserver
Watch for DOM mutations and re-run KaTeX. More robust than useLayoutEffect but still a workaround for the wrong architecture. Added complexity for the same outcome.

### Table backwards compatibility fallback
Keep `dangerouslySetInnerHTML` for old table cells (`typeof cell === 'string'` check). Would require keeping DOMPurify. Adds conditional code path and security dependency for temporary benefit. Rejected — empty cells are acceptable, user re-extracts.

### AST slicing in frontend (Option B from previous session)
Port `slice_ast` to TypeScript and split block AST on the frontend using audio_chunk text lengths as boundaries. Duplicates complex slicing logic. Rejected — storing per-chunk AST on AudioChunk is simpler (backend already computes it).

## Sources

**Knowledge files:**
- [[frontend]] — Playback engine, component architecture, dangerouslySetInnerHTML gotchas
- [[document-processing]] — Block structure, AST, split_with_spans, structured content format

**Key code files:**
- MUST READ: `frontend/src/components/structuredDocument.tsx` — ALL dangerouslySetInnerHTML call sites, KaTeX useEffect, block views, TypeScript types
- MUST READ: `yapit/gateway/markdown/models.py` — AudioChunk, InlineContent types, TableBlock, all block models
- MUST READ: `yapit/gateway/markdown/transformer.py` — `split_with_spans` (line 554), `slice_ast` (line 605), `render_ast_to_html` (line 708), `_transform_table` (line 1418), `transform_inline_to_ast` (line 271), `_transform_inline_node` (line 349), `InlineProcessor._node_to_html` (line 139, esp html_inline pass-through at line 172)
- Reference: `frontend/src/lib/playbackEngine.ts` — Uses `data-audio-idx` spans for highlighting
- Reference: `tests/yapit/gateway/markdown/test_markdown.py` — Existing transformer tests

**Previous session:**
- `agent/transcripts/2026-02-10-frontend-ux-fixes-latex-ast-renderer-plan-playback-diagnostics.txt` — Full discussion, initial plan, user preferences on backwards compat
