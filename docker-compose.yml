volumes:
  pgdata:
  metricsdata:
  markxiv-cache:

services:
  # -------- database
  postgres:
    init: true
    image: postgres:16-alpine
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U $${POSTGRES_USER:-yapit}"]
      start_period: 30s
      start_interval: 1s
      interval: 30s
      timeout: 3s
      retries: 10

  # -------- metrics (separate from main postgres for isolation)
  metrics-db:
    init: true
    image: timescale/timescaledb:latest-pg16
    restart: unless-stopped
    environment:
      POSTGRES_USER: metrics
      POSTGRES_PASSWORD: metrics
      POSTGRES_DB: metrics
    volumes:
      - metricsdata:/var/lib/postgresql/data
      - ./docker/metrics-init.sql:/docker-entrypoint-initdb.d/init.sql:ro
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U metrics"]
      start_period: 30s
      start_interval: 1s
      interval: 30s
      timeout: 3s
      retries: 10

  # -------- cache / queue
  redis:
    init: true
    image: redis:7-alpine
    restart: unless-stopped

  smokescreen:
    init: true
    build:
      dockerfile: ./docker/Dockerfile.smokescreen
    restart: unless-stopped

  # -------- api-gateway
  gateway:
    init: true
    build:
      context: .
      dockerfile: yapit/gateway/Dockerfile
    depends_on:
      redis:
        condition: service_started
      postgres:
        condition: service_healthy
      metrics-db:
        condition: service_healthy
      stack-auth:
        condition: service_started
      smokescreen:
        condition: service_started
      markxiv:
        condition: service_healthy
    restart: unless-stopped
    expose: ["8000"]
    healthcheck:
      test: ["CMD", "python", "-c", "import urllib.request; urllib.request.urlopen('http://localhost:8000/health').read()"]
      start_period: 80s 
      start_interval: 1s
      interval: 30s
      timeout: 5s
      retries: 10

  # -------- auth
  stack-auth:
    build:
      dockerfile: ./docker/Dockerfile.stackauth
    restart: unless-stopped
    depends_on:
      postgres:
        condition: service_healthy
    healthcheck:
       test: ["CMD-SHELL",
         "curl -fs http://localhost:8101/health && \
          curl -fs http://localhost:8102/health"]
       start_period: 180s
       start_interval: 2s
       interval: 30s
       timeout: 10s
       retries: 15

  # svix:
  #   image: svix/svix-server
  #   restart: unless-stopped
  #   env_file: ./.env.prod

  # -------- arxiv processor
  markxiv:
    init: true
    build:
      dockerfile: ./docker/Dockerfile.markxiv
    restart: unless-stopped
    environment:
      PORT: "8080"
      MARKXIV_CACHE_CAP: "500"
      MARKXIV_DISK_CACHE_CAP_BYTES: "10737418240"  # 10GB
      MARKXIV_CACHE_DIR: /cache
    volumes:
      - markxiv-cache:/cache
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/health"]
      start_period: 10s
      interval: 30s
      timeout: 3s
      retries: 3

  # -------- workers
  kokoro-cpu:
    init: true
    build:
      context: .
      dockerfile: yapit/workers/kokoro/Dockerfile.cpu
    command: python -m yapit.workers.kokoro
    environment:
      REDIS_URL: redis://redis:6379
      OMP_NUM_THREADS: ${OMP_NUM_THREADS}
    restart: unless-stopped
    deploy:
      replicas: ${KOKORO_CPU_REPLICAS}

  yolo-cpu:
    init: true
    build:
      context: .
      dockerfile: yapit/workers/yolo/Dockerfile.cpu
    command: python -m yapit.workers.yolo
    environment:
      REDIS_URL: redis://redis:6379
      OMP_NUM_THREADS: ${OMP_NUM_THREADS}
    restart: unless-stopped
    deploy:
      replicas: ${YOLO_CPU_REPLICAS}

