volumes:
  pgdata:
  metricsdata:

services:
  # -------- database
  postgres:
    init: true
    image: postgres:16-alpine
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U $${POSTGRES_USER:-yapit}"]
      start_period: 30s
      start_interval: 1s
      interval: 30s
      timeout: 3s
      retries: 10

  # -------- metrics (separate from main postgres for isolation)
  metrics-db:
    init: true
    image: timescale/timescaledb:latest-pg16
    restart: unless-stopped
    environment:
      POSTGRES_USER: metrics
      POSTGRES_PASSWORD: metrics
      POSTGRES_DB: metrics
    volumes:
      - metricsdata:/var/lib/postgresql/data
      - ./docker/metrics-init.sql:/docker-entrypoint-initdb.d/init.sql:ro
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U metrics"]
      start_period: 30s
      start_interval: 1s
      interval: 30s
      timeout: 3s
      retries: 10

  # -------- cache / queue
  redis:
    init: true
    image: redis:7-alpine
    restart: unless-stopped

  smokescreen:
    init: true
    build:
      dockerfile: ./docker/Dockerfile.smokescreen
    restart: unless-stopped

  # -------- api-gateway
  gateway:
    init: true
    build:
      context: .
      dockerfile: yapit/gateway/Dockerfile
    env_file:
      - ./.env.prod
    environment:
      ENV_FILE: .env.prod
    volumes:
      - ./tts_processors.prod.json:/app/tts_processors.prod.json:ro
    depends_on:
      redis:
        condition: service_started
      postgres:
        condition: service_healthy
      metrics-db:
        condition: service_healthy
      stack-auth:
        condition: service_started
      smokescreen:
        condition: service_started
    restart: unless-stopped
    expose: ["8000"]
    healthcheck:
      test: ["CMD", "python", "-c", "import urllib.request; urllib.request.urlopen('http://localhost:8000/health').read()"]
      start_period: 80s 
      start_interval: 1s
      interval: 30s
      timeout: 5s
      retries: 10

  # -------- auth
  stack-auth:
    build:
      dockerfile: ./docker/Dockerfile.stackauth
    restart: unless-stopped
    env_file: ./.env.prod
    depends_on:
      postgres:
        condition: service_healthy
    healthcheck:
       test: ["CMD-SHELL",
         "curl -fs http://localhost:8101/health && \
          curl -fs http://localhost:8102/health"]
       start_period: 180s
       start_interval: 2s
       interval: 30s
       timeout: 10s
       retries: 15

  # svix:
  #   image: svix/svix-server
  #   restart: unless-stopped
  #   env_file: ./.env.prod

  # -------- workers
  kokoro-cpu:
    init: true
    build:
      context: .
      dockerfile: yapit/workers/kokoro/Dockerfile.cpu
    command: python -m yapit.workers.kokoro
    environment:
      ADAPTER_CLASS: yapit.workers.adapters.kokoro.KokoroAdapter
      OMP_NUM_THREADS: ${OMP_NUM_THREADS}
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "python", "-c", "import urllib.request; urllib.request.urlopen('http://localhost:8000/health')"]
      interval: 10s
      timeout: 5s
      retries: 30
      start_period: 60s
    deploy:
      replicas: ${KOKORO_CPU_REPLICAS}

  yolo-cpu:
    init: true
    build:
      context: .
      dockerfile: yapit/workers/yolo/Dockerfile.cpu
    command: python -m yapit.workers.yolo
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "python", "-c", "import urllib.request; urllib.request.urlopen('http://localhost:8000/health')"]
      interval: 10s
      timeout: 5s
      retries: 30
      start_period: 60s
    deploy:
      replicas: ${YOLO_CPU_REPLICAS}

