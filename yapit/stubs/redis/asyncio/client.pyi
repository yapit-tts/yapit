from typing import Any, AsyncIterator

from redis.typing import EncodableT, KeyT

class PubSub:
    async def subscribe(self, *args: str, **kwargs: Any) -> None: ...
    async def unsubscribe(self, *args: str) -> None: ...
    def listen(self) -> AsyncIterator[dict[str, Any]]: ...
    async def close(self) -> None: ...

class Redis:
    @classmethod
    async def from_url(cls, url: str, **kwargs: Any) -> Redis: ...
    async def aclose(self) -> None: ...
    async def lpush(self, name: KeyT, *values: EncodableT) -> int: ...
    async def llen(self, name: KeyT) -> int: ...
    async def brpop(self, keys: list[KeyT], timeout: int = 0) -> tuple[bytes, bytes]: ...
    async def set(self, name: KeyT, value: EncodableT, **kwargs: Any) -> bool | None: ...
    async def exists(self, *names: KeyT) -> int: ...
    async def delete(self, *names: KeyT) -> int: ...
    async def publish(self, channel: str, message: EncodableT) -> int: ...
    def pubsub(self, **kwargs: Any) -> PubSub: ...
    async def sadd(self, name: KeyT, *values: EncodableT) -> int: ...
    async def srem(self, name: KeyT, *values: EncodableT) -> int: ...
    async def sismember(self, name: KeyT, value: EncodableT) -> bool: ...
    async def smembers(self, name: KeyT) -> set[bytes]: ...
    async def expire(self, name: KeyT, time: int) -> bool: ...
