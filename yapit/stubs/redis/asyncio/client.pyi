import builtins
from typing import Any, AsyncIterator

from redis.typing import EncodableT, KeyT

class PubSub:
    async def subscribe(self, *args: str, **kwargs: Any) -> None: ...
    async def unsubscribe(self, *args: str) -> None: ...
    def listen(self) -> AsyncIterator[dict[str, Any]]: ...
    async def close(self) -> None: ...

class Redis:
    @classmethod
    async def from_url(cls, url: str, **kwargs: Any) -> Redis: ...
    async def aclose(self) -> None: ...

    # String
    async def get(self, name: KeyT) -> bytes | None: ...
    async def set(self, name: KeyT, value: EncodableT, **kwargs: Any) -> bool | None: ...
    async def setex(self, name: KeyT, time: int, value: EncodableT) -> bool: ...
    async def incr(self, name: KeyT, amount: int = 1) -> int: ...
    async def incrby(self, name: KeyT, amount: int = 1) -> int: ...
    async def decr(self, name: KeyT, amount: int = 1) -> int: ...

    # List
    async def lpush(self, name: KeyT, *values: EncodableT) -> int: ...
    async def llen(self, name: KeyT) -> int: ...
    async def rpop(self, name: KeyT) -> bytes | None: ...
    async def brpop(self, keys: KeyT | list[KeyT], timeout: int = 0) -> tuple[bytes, bytes] | None: ...

    # Set
    async def sadd(self, name: KeyT, *values: EncodableT) -> int: ...
    async def srem(self, name: KeyT, *values: EncodableT) -> int: ...
    async def sismember(self, name: KeyT, value: EncodableT) -> bool: ...
    async def smembers(self, name: KeyT) -> builtins.set[bytes]: ...

    # Hash
    async def hset(self, name: KeyT, key: KeyT, value: EncodableT) -> int: ...
    async def hget(self, name: KeyT, key: KeyT) -> bytes | None: ...
    async def hdel(self, name: KeyT, *keys: KeyT) -> int: ...
    async def hgetall(self, name: KeyT) -> dict[bytes, bytes]: ...
    async def hvals(self, name: KeyT) -> list[bytes]: ...

    # Sorted set
    async def zadd(self, name: KeyT, mapping: dict[str, float], **kwargs: Any) -> int: ...
    async def zcard(self, name: KeyT) -> int: ...
    async def zrem(self, name: KeyT, *values: str) -> int: ...
    async def zrange(self, name: KeyT, start: int, end: int, withscores: bool = False, **kwargs: Any) -> list[Any]: ...
    async def zrangebyscore(self, name: KeyT, min: float | str, max: float | str, start: int | None = None, num: int | None = None, withscores: bool = False, score_cast_func: Any = ...) -> list[Any]: ...
    async def bzpopmin(self, keys: KeyT, timeout: float = 0) -> tuple[bytes, bytes, float] | None: ...

    # Keys
    async def exists(self, *names: KeyT) -> int: ...
    async def delete(self, *names: KeyT) -> int: ...
    async def expire(self, name: KeyT, time: int) -> bool: ...
    async def scan(self, cursor: int = 0, match: str | None = None, count: int | None = None, **kwargs: Any) -> tuple[int, list[bytes]]: ...
    def scan_iter(self, match: str | None = None, count: int | None = None, **kwargs: Any) -> AsyncIterator[bytes]: ...

    # Pub/Sub
    async def publish(self, channel: str, message: EncodableT) -> int: ...
    def pubsub(self, **kwargs: Any) -> PubSub: ...
